{
  "_meta": {
    "version": "1.2.0",
    "description": "Agent-Zero intent disambiguation taxonomy. Add domains freely — no code changes required.",
    "resolver_types": [
      "keyword_map",
      "file_extension_inference",
      "last_mentioned_file",
      "last_mentioned_path",
      "last_mentioned_entity",
      "context_inference",
      "history_scan",
      "working_memory_lookup"
    ],
    "changelog": {
      "1.2.0": "Added working_memory_lookup resolver type. Wired into file/path/container/branch/package slots across domains.",
      "1.1.0": "Added git_ops, docker_ops, config_edit, prompt_engineering, log_analysis, pdf_ops, data_transform, api_integration, dependency_mgmt"
    }
  },

  "domains": {

    "codegen": {
      "description": "Writing, creating, or generating new code",
      "triggers": [
        "write", "create", "generate", "build", "implement", "scaffold",
        "make a", "make me", "produce", "draft", "code", "function",
        "class", "script", "module", "program"
      ],
      "required_slots": ["target_file", "operation"],
      "optional_slots": ["language", "preserve_behavior", "style", "scope", "return_type"],
      "slot_definitions": {
        "target_file": {
          "question": "Which file should I write to, or should I create a new one?",
          "resolvers": ["last_mentioned_file", "working_memory_lookup", "context_inference"],
          "type": "string",
          "nullable": true,
          "null_means": "create_new"
        },
        "operation": {
          "question": null,
          "resolvers": ["keyword_map"],
          "keyword_map": {
            "write": "create", "create": "create", "generate": "create",
            "build": "create", "implement": "create", "scaffold": "create",
            "add": "extend", "extend": "extend", "append": "extend",
            "rewrite": "rewrite", "replace": "rewrite", "redo": "rewrite"
          },
          "type": "enum",
          "default": "create"
        },
        "language": {
          "question": null,
          "resolvers": ["file_extension_inference", "context_inference", "history_scan"],
          "type": "string",
          "nullable": true
        },
        "preserve_behavior": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "bool",
          "default": true
        },
        "scope": {
          "question": "Should this apply to the whole file or a specific function/section?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true
        }
      },
      "confidence_threshold": 0.65,
      "preamble": "Identify the language. State exactly what needs to be written. Produce complete, runnable code only — no placeholders.",
      "dialogue_acts": {
        "INFORM": "User provided code or spec",
        "REQUEST_CODE": "User wants code generated",
        "CLARIFY_SCOPE": "Scope of change is unclear"
      }
    },

    "refactor": {
      "description": "Improving existing code without changing behavior",
      "triggers": [
        "refactor", "clean up", "clean", "tidy", "simplify", "optimize",
        "improve", "fix style", "reorganize", "restructure", "lint",
        "make it better", "make this better", "make cleaner"
      ],
      "required_slots": ["target_file", "operation"],
      "optional_slots": ["preserve_behavior", "style_guide", "scope"],
      "slot_definitions": {
        "target_file": {
          "question": "Which file should I refactor?",
          "resolvers": ["last_mentioned_file", "working_memory_lookup", "context_inference"],
          "type": "string",
          "nullable": false
        },
        "operation": {
          "question": null,
          "resolvers": ["keyword_map"],
          "keyword_map": {
            "refactor": "refactor", "clean": "refactor", "clean up": "refactor",
            "tidy": "refactor", "simplify": "simplify", "optimize": "optimize",
            "improve": "refactor", "reorganize": "reorganize"
          },
          "type": "enum",
          "default": "refactor"
        },
        "preserve_behavior": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "bool",
          "default": true
        },
        "scope": {
          "question": "Should this apply to the whole file or a specific function?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true
        }
      },
      "confidence_threshold": 0.7,
      "preamble": "Preserve all existing behavior exactly. List only the specific changes made. Show the complete modified code."
    },

    "bugfix": {
      "description": "Diagnosing and fixing broken code",
      "triggers": [
        "fix", "debug", "broken", "error", "bug", "crash", "exception",
        "not working", "doesn't work", "fails", "failing", "wrong output",
        "traceback", "syntax error", "runtime error", "it broke"
      ],
      "required_slots": ["target_file", "error_description"],
      "optional_slots": ["error_text", "expected_behavior", "scope"],
      "slot_definitions": {
        "target_file": {
          "question": "Which file contains the bug?",
          "resolvers": ["last_mentioned_file", "working_memory_lookup", "context_inference"],
          "type": "string",
          "nullable": false
        },
        "error_description": {
          "question": "What is the error or wrong behavior you are seeing?",
          "resolvers": ["context_inference", "history_scan"],
          "type": "string",
          "nullable": false
        },
        "error_text": {
          "question": null,
          "resolvers": ["history_scan"],
          "type": "string",
          "nullable": true,
          "note": "Scan recent history for traceback or error message"
        },
        "expected_behavior": {
          "question": "What should it do instead?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true
        }
      },
      "confidence_threshold": 0.7,
      "preamble": "Identify the root cause first. Explain it in one sentence. Then provide the complete fixed code."
    },

    "agentic": {
      "description": "Executing a multi-step task or workflow via tools",
      "triggers": [
        "run", "execute", "do", "perform", "handle", "manage", "automate",
        "set up", "deploy", "install", "configure", "process", "start",
        "launch", "spin up", "take care of"
      ],
      "required_slots": ["target", "operation"],
      "optional_slots": ["constraints", "scope", "output_format", "confirmation_required"],
      "slot_definitions": {
        "target": {
          "question": "What should I operate on — a file, a directory, a service, or something else?",
          "resolvers": ["last_mentioned_path", "last_mentioned_entity", "working_memory_lookup", "context_inference"],
          "type": "string",
          "nullable": false
        },
        "operation": {
          "question": "What specifically should be done?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "run": "execute", "execute": "execute", "start": "start",
            "install": "install", "deploy": "deploy", "configure": "configure",
            "set up": "configure", "process": "process", "manage": "manage"
          },
          "type": "string",
          "nullable": false
        },
        "constraints": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true
        },
        "confirmation_required": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "bool",
          "default": false,
          "note": "Set true for destructive operations"
        }
      },
      "confidence_threshold": 0.75,
      "preamble": "Select one tool. State your reasoning in one sentence. Output valid JSON only. Do not chain tools without confirming intermediate results."
    },

    "file_ops": {
      "description": "File and directory manipulation: move, copy, delete, rename, search",
      "triggers": [
        "move", "copy", "delete", "remove", "rename", "find", "search",
        "read", "open", "list", "show files", "what files", "where is",
        "locate", "scan", "grep"
      ],
      "required_slots": ["source_path", "operation"],
      "optional_slots": ["destination_path", "conflict_resolution", "filter", "recursive"],
      "slot_definitions": {
        "source_path": {
          "question": "What is the source path or file you want me to work with?",
          "resolvers": ["last_mentioned_path", "last_mentioned_file", "working_memory_lookup", "context_inference"],
          "type": "path",
          "nullable": false
        },
        "operation": {
          "question": null,
          "resolvers": ["keyword_map"],
          "keyword_map": {
            "move": "move", "copy": "copy", "delete": "delete",
            "remove": "delete", "rename": "rename", "find": "search",
            "search": "search", "locate": "search", "grep": "search",
            "read": "read", "open": "read", "list": "list", "scan": "list"
          },
          "type": "enum",
          "nullable": false
        },
        "destination_path": {
          "question": "Where should it go?",
          "resolvers": ["working_memory_lookup", "context_inference"],
          "type": "path",
          "nullable": true,
          "required_when": {"operation": ["move", "copy", "rename"]}
        },
        "conflict_resolution": {
          "question": "If a file already exists at the destination, should I overwrite, skip, or rename it?",
          "resolvers": ["context_inference"],
          "type": "enum",
          "enum_values": ["overwrite", "skip", "rename_new"],
          "nullable": true,
          "required_when": {"operation": ["move", "copy"]}
        },
        "recursive": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "bool",
          "default": false
        }
      },
      "confidence_threshold": 0.8,
      "preamble": "Confirm the exact source and destination paths before executing. For destructive operations, state what will be lost."
    },

    "analysis": {
      "description": "Explaining, comparing, reviewing, or assessing something",
      "triggers": [
        "analyze", "explain", "describe", "compare", "review", "assess",
        "evaluate", "summarize", "what does", "what is", "how does",
        "why is", "tell me about", "break down", "walk me through",
        "understand", "look at"
      ],
      "required_slots": ["subject"],
      "optional_slots": ["depth", "output_format", "comparison_target", "focus_area"],
      "slot_definitions": {
        "subject": {
          "question": "What specifically should I analyze?",
          "resolvers": ["context_inference", "last_mentioned_entity", "last_mentioned_file"],
          "type": "string",
          "nullable": false
        },
        "depth": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "enum",
          "enum_values": ["brief", "standard", "deep"],
          "default": "standard"
        },
        "comparison_target": {
          "question": "What should I compare it against?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "required_when": {"trigger_contains": ["compare", "vs", "versus", "difference"]}
        },
        "focus_area": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true
        }
      },
      "confidence_threshold": 0.6,
      "preamble": "Break the subject into sub-components. Address each explicitly before synthesizing a conclusion."
    },

    "osint": {
      "description": "Research, data gathering, site analysis, document investigation",
      "triggers": [
        "research", "investigate", "look up", "find information", "gather",
        "scrape", "crawl", "fetch", "retrieve", "monitor", "track",
        "osint", "scan site", "analyze site", "check"
      ],
      "required_slots": ["target", "information_type"],
      "optional_slots": ["depth", "output_format", "filters", "source_constraints"],
      "slot_definitions": {
        "target": {
          "question": "What is the URL, domain, or subject to investigate?",
          "resolvers": ["working_memory_lookup", "context_inference", "last_mentioned_entity"],
          "type": "string",
          "nullable": false
        },
        "information_type": {
          "question": "What type of information are you looking for?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "research": "general", "investigate": "deep_analysis",
            "scrape": "structured_data", "crawl": "structured_data",
            "monitor": "change_detection", "check": "status"
          },
          "type": "enum",
          "enum_values": ["general", "deep_analysis", "structured_data", "change_detection", "status"],
          "nullable": false
        },
        "depth": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "enum",
          "enum_values": ["surface", "standard", "deep"],
          "default": "standard"
        }
      },
      "confidence_threshold": 0.65,
      "preamble": "State the target and what is being sought before beginning. Use structured output. Cite sources."
    },

    "skill_building": {
      "description": "Creating Agent-Zero skills, extensions, tools, or prompt patches",
      "triggers": [
        "build a skill", "create a skill", "write a skill", "make a skill",
        "build an extension", "create extension", "write extension",
        "new tool", "build tool", "agent zero skill", "hardening"
      ],
      "required_slots": ["skill_type", "purpose"],
      "optional_slots": ["hook_point", "language", "integration_target"],
      "slot_definitions": {
        "skill_type": {
          "question": "Is this a skill, extension, prompt patch, or framework replacement?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "skill": "skill", "extension": "extension",
            "prompt patch": "prompt_patch", "fw replacement": "fw_replacement",
            "framework replacement": "fw_replacement"
          },
          "type": "enum",
          "enum_values": ["skill", "extension", "prompt_patch", "fw_replacement"],
          "nullable": false
        },
        "purpose": {
          "question": "What problem should this solve or what capability should it add?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": false
        },
        "hook_point": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "e.g. before_main_llm_call, error_format, tool_execute_after"
        }
      },
      "confidence_threshold": 0.65,
      "preamble": "State the hook point, input/output contract, and failure behavior before writing any code."
    },

    "git_ops": {
      "description": "Git version control operations: commit, push, pull, branch, merge, diff, stash, log",
      "triggers": [
        "git", "commit", "push", "pull", "branch", "merge", "checkout",
        "stash", "diff", "log", "status", "add files", "stage", "unstage",
        "rebase", "cherry-pick", "tag", "clone", "init repo", "amend"
      ],
      "required_slots": ["operation"],
      "optional_slots": ["branch_name", "commit_message", "remote", "file_scope", "force"],
      "slot_definitions": {
        "operation": {
          "question": "What git operation should I perform?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "commit": "commit", "save changes": "commit",
            "push": "push", "upload": "push", "publish": "push",
            "pull": "pull", "fetch": "pull", "sync": "pull",
            "branch": "branch", "new branch": "branch", "switch": "checkout",
            "checkout": "checkout", "merge": "merge", "combine": "merge",
            "stash": "stash", "shelve": "stash",
            "diff": "diff", "changes": "diff", "what changed": "diff",
            "log": "log", "history": "log", "status": "status",
            "stage": "add", "add": "add", "unstage": "restore"
          },
          "type": "enum",
          "enum_values": ["commit", "push", "pull", "branch", "checkout", "merge", "stash", "diff", "log", "status", "add", "restore", "rebase", "tag"],
          "nullable": false
        },
        "commit_message": {
          "question": "What should the commit message be?",
          "resolvers": ["context_inference", "history_scan"],
          "type": "string",
          "nullable": true,
          "required_when": {"operation": ["commit"]},
          "note": "Always ask if not provided — auto-generated messages from local models are unreliable"
        },
        "branch_name": {
          "question": "Which branch?",
          "resolvers": ["context_inference", "last_mentioned_entity", "working_memory_lookup", "history_scan"],
          "type": "string",
          "nullable": true,
          "required_when": {"operation": ["branch", "checkout", "merge"]}
        },
        "remote": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "default": "origin"
        },
        "file_scope": {
          "question": null,
          "resolvers": ["last_mentioned_file", "last_mentioned_path", "working_memory_lookup", "context_inference"],
          "type": "string",
          "nullable": true,
          "note": "Specific file(s) to scope the operation to, if not all"
        },
        "force": {
          "question": "This will force-push and overwrite remote history. Are you sure?",
          "resolvers": ["context_inference"],
          "type": "bool",
          "default": false,
          "note": "Require explicit confirmation before setting true"
        }
      },
      "confidence_threshold": 0.75,
      "preamble": "State the exact git command before executing. For commit: if no message is provided, ask for one — do not invent it. For destructive operations (force push, hard reset, branch delete), state what will be permanently lost."
    },

    "docker_ops": {
      "description": "Docker container and image operations: run, exec, logs, build, stop, pull, inspect",
      "triggers": [
        "docker", "container", "image", "dockerfile", "compose",
        "exec into", "shell into", "container logs", "docker logs",
        "pull image", "build image", "stop container", "restart container",
        "docker run", "docker exec", "docker build", "docker ps",
        "spin up container", "container shell"
      ],
      "required_slots": ["operation"],
      "optional_slots": ["container_name", "image_name", "command", "port_mapping", "volume_mount", "env_vars"],
      "slot_definitions": {
        "operation": {
          "question": "What docker operation should I perform?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "run": "run", "start": "run", "spin up": "run",
            "exec": "exec", "shell": "exec", "exec into": "exec", "shell into": "exec",
            "logs": "logs", "log": "logs", "output": "logs",
            "build": "build", "build image": "build",
            "stop": "stop", "kill": "stop",
            "restart": "restart",
            "pull": "pull", "download image": "pull",
            "ps": "ps", "list containers": "ps", "running containers": "ps",
            "inspect": "inspect", "info": "inspect",
            "rm": "remove", "remove": "remove", "delete container": "remove",
            "rmi": "remove_image", "remove image": "remove_image"
          },
          "type": "enum",
          "enum_values": ["run", "exec", "logs", "build", "stop", "restart", "pull", "ps", "inspect", "remove", "remove_image"],
          "nullable": false
        },
        "container_name": {
          "question": "Which container?",
          "resolvers": ["last_mentioned_entity", "context_inference", "working_memory_lookup", "history_scan"],
          "type": "string",
          "nullable": true,
          "required_when": {"operation": ["exec", "logs", "stop", "restart", "inspect", "remove"]}
        },
        "image_name": {
          "question": "Which image?",
          "resolvers": ["last_mentioned_entity", "working_memory_lookup", "context_inference"],
          "type": "string",
          "nullable": true,
          "required_when": {"operation": ["run", "pull", "build", "remove_image"]}
        },
        "command": {
          "question": "What command should I run inside the container?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "required_when": {"operation": ["exec"]},
          "default": "/bin/bash"
        },
        "port_mapping": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "e.g. 8080:80"
        },
        "volume_mount": {
          "question": null,
          "resolvers": ["last_mentioned_path", "context_inference"],
          "type": "string",
          "nullable": true
        }
      },
      "confidence_threshold": 0.8,
      "preamble": "State the exact docker command before executing. For stop/remove operations, confirm the container name matches before proceeding. For exec, confirm the container is running first."
    },

    "config_edit": {
      "description": "Editing configuration files: env files, YAML, TOML, JSON config, INI, systemd units",
      "triggers": [
        "config", "configuration", "settings", "env file", ".env",
        "yaml config", "toml", "ini file", "edit config", "update config",
        "change setting", "set value", "update value", "klipper config",
        "printer config", "secrets", "environment variable", "set env"
      ],
      "required_slots": ["target_file", "config_key", "new_value"],
      "optional_slots": ["current_value", "format", "backup_first", "section"],
      "slot_definitions": {
        "target_file": {
          "question": "Which configuration file should I edit?",
          "resolvers": ["last_mentioned_file", "last_mentioned_path", "working_memory_lookup", "context_inference"],
          "type": "path",
          "nullable": false
        },
        "config_key": {
          "question": "Which key or setting should I change?",
          "resolvers": ["context_inference", "last_mentioned_entity"],
          "type": "string",
          "nullable": false
        },
        "new_value": {
          "question": "What should the new value be?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": false
        },
        "current_value": {
          "question": null,
          "resolvers": ["history_scan", "context_inference"],
          "type": "string",
          "nullable": true,
          "note": "Resolve from recent history or file read if possible — useful for confirmation"
        },
        "format": {
          "question": null,
          "resolvers": ["file_extension_inference", "context_inference"],
          "type": "enum",
          "enum_values": ["env", "yaml", "toml", "json", "ini", "cfg", "conf"],
          "nullable": true
        },
        "backup_first": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "bool",
          "default": true,
          "note": "Default true — config edits should always back up first"
        },
        "section": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "INI/TOML section name if applicable"
        }
      },
      "confidence_threshold": 0.85,
      "preamble": "Before editing: state the file path, the exact key being changed, the current value, and the new value. Back up the file first unless explicitly told not to. For .env and secrets files, do not echo values to the response."
    },

    "prompt_engineering": {
      "description": "Writing, rewriting, or optimizing prompts, system messages, preambles, and few-shot examples",
      "triggers": [
        "prompt", "system prompt", "system message", "preamble", "few-shot",
        "few shot", "rewrite prompt", "improve prompt", "tighten prompt",
        "write a prompt", "prompt for", "instruction", "jinja template",
        "chat template", "preamble for", "prompt patch", "fw message",
        "behavioral goal", "model instruction"
      ],
      "required_slots": ["prompt_type", "behavioral_goal"],
      "optional_slots": ["target_model", "token_budget", "existing_prompt", "output_format"],
      "slot_definitions": {
        "prompt_type": {
          "question": "What type of prompt is this — system message, user-turn instruction, few-shot example, or preamble?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "system prompt": "system", "system message": "system",
            "preamble": "preamble", "fw message": "fw_message",
            "few-shot": "few_shot", "few shot": "few_shot", "example": "few_shot",
            "user prompt": "user_turn", "instruction": "user_turn",
            "jinja": "chat_template", "chat template": "chat_template"
          },
          "type": "enum",
          "enum_values": ["system", "preamble", "fw_message", "few_shot", "user_turn", "chat_template"],
          "nullable": false
        },
        "behavioral_goal": {
          "question": "What behavior or output should this prompt produce?",
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": false
        },
        "target_model": {
          "question": null,
          "resolvers": ["context_inference", "history_scan"],
          "type": "string",
          "nullable": true,
          "note": "e.g. Qwen3-14B, GLM-4.7, Devstral — affects vocabulary and format choices"
        },
        "token_budget": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "Approximate token ceiling for the prompt"
        },
        "existing_prompt": {
          "question": null,
          "resolvers": ["history_scan", "last_mentioned_file"],
          "type": "string",
          "nullable": true,
          "note": "The current prompt being improved, if any"
        }
      },
      "confidence_threshold": 0.7,
      "preamble": "State the target model, the behavioral goal, and any token constraints before writing. Optimize for clarity at inference time, not human readability. Prefer imperative over declarative phrasing. Show the complete prompt — no ellipsis or placeholders."
    },

    "log_analysis": {
      "description": "Reading, parsing, and diagnosing agent logs, system logs, or error output",
      "triggers": [
        "log", "logs", "agent log", "check log", "read log", "show log",
        "what happened", "last run", "why did", "error in log",
        "warning in log", "log output", "bst log", "watchdog log",
        "context log", "extension log", "check the output", "tail log",
        "recent errors", "what failed", "log file"
      ],
      "required_slots": ["log_source"],
      "optional_slots": ["error_pattern", "time_range", "verbosity_filter", "last_n_lines"],
      "slot_definitions": {
        "log_source": {
          "question": "Which log file or output stream should I check?",
          "resolvers": ["keyword_map", "last_mentioned_file", "working_memory_lookup", "context_inference"],
          "keyword_map": {
            "agent log": "/a0/logs/agent.log",
            "agent.log": "/a0/logs/agent.log",
            "bst log": "/a0/logs/agent.log",
            "watchdog log": "/a0/logs/agent.log",
            "docker log": "docker_logs",
            "system log": "/var/log/syslog",
            "klipper log": "/tmp/klippy.log",
            "moonraker log": "/tmp/moonraker.log"
          },
          "type": "string",
          "nullable": false
        },
        "error_pattern": {
          "question": null,
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "bst": "[BST]", "watchdog": "[CTX]", "retry": "RepairableException",
            "failure tracker": "failure_count", "tool error": "tool_name"
          },
          "type": "string",
          "nullable": true
        },
        "time_range": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "e.g. 'last 5 minutes', 'since restart'"
        },
        "last_n_lines": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "default": "100"
        },
        "verbosity_filter": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "enum",
          "enum_values": ["ERROR", "WARNING", "INFO", "DEBUG", "ALL"],
          "default": "ALL"
        }
      },
      "confidence_threshold": 0.65,
      "preamble": "Scan for ERROR and WARNING lines first. State the first failure event and its timestamp before summarizing patterns. Quote the exact log line when identifying a specific issue — do not paraphrase errors."
    },

    "pdf_ops": {
      "description": "PDF operations: extract text, merge, split, OCR, form-fill, convert",
      "triggers": [
        "pdf", "extract pdf", "merge pdf", "split pdf", "ocr", "form fill",
        "pdf form", "convert pdf", "pdf to", "to pdf", "read pdf",
        "parse pdf", "pdf text", "pdf pages", "rotate pdf", "pdf images",
        "pdf library", "pdf skill"
      ],
      "required_slots": ["operation", "source_file"],
      "optional_slots": ["output_format", "page_range", "destination_file", "ocr_language"],
      "slot_definitions": {
        "operation": {
          "question": "What should I do with the PDF?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "extract": "extract_text", "extract text": "extract_text", "read": "extract_text",
            "parse": "extract_text", "text": "extract_text",
            "merge": "merge", "combine": "merge", "join": "merge",
            "split": "split", "separate": "split",
            "ocr": "ocr", "scan": "ocr", "optical": "ocr",
            "form": "form_fill", "fill": "form_fill", "fill in": "form_fill",
            "convert": "convert", "to pdf": "convert", "pdf to": "convert",
            "rotate": "rotate", "images": "extract_images", "extract images": "extract_images"
          },
          "type": "enum",
          "enum_values": ["extract_text", "merge", "split", "ocr", "form_fill", "convert", "rotate", "extract_images"],
          "nullable": false
        },
        "source_file": {
          "question": "Which PDF file should I work with?",
          "resolvers": ["last_mentioned_file", "last_mentioned_path", "working_memory_lookup", "context_inference"],
          "type": "path",
          "nullable": false
        },
        "output_format": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true
        },
        "page_range": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "e.g. '1-5', '3', 'all'"
        },
        "destination_file": {
          "question": null,
          "resolvers": ["context_inference", "last_mentioned_path"],
          "type": "path",
          "nullable": true
        },
        "ocr_language": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "default": "eng"
        }
      },
      "confidence_threshold": 0.7,
      "preamble": "Load the pdf_library skill before attempting any operation. Verify the source file exists at the stated path. Use full absolute paths. State the output location before writing."
    },

    "data_transform": {
      "description": "Format conversion and data restructuring: JSON, CSV, YAML, XML, TSV, schema mapping",
      "triggers": [
        "convert", "transform", "parse", "format", "reformat",
        "json to", "csv to", "yaml to", "to json", "to csv", "to yaml",
        "restructure data", "reshape", "normalize data", "flatten",
        "serialize", "deserialize", "map fields", "schema", "data mapping",
        "extract fields", "filter rows", "aggregate"
      ],
      "required_slots": ["input_format", "output_format"],
      "optional_slots": ["source_file", "destination_file", "field_mapping", "filter_expression"],
      "slot_definitions": {
        "input_format": {
          "question": "What is the current data format?",
          "resolvers": ["keyword_map", "file_extension_inference", "context_inference"],
          "keyword_map": {
            "json": "json", "csv": "csv", "yaml": "yaml", "yml": "yaml",
            "xml": "xml", "tsv": "tsv", "toml": "toml", "ini": "ini",
            "markdown": "markdown", "text": "text", "plain": "text"
          },
          "type": "enum",
          "enum_values": ["json", "csv", "yaml", "xml", "tsv", "toml", "ini", "markdown", "text"],
          "nullable": false
        },
        "output_format": {
          "question": "What format should it be converted to?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "json": "json", "csv": "csv", "yaml": "yaml", "yml": "yaml",
            "xml": "xml", "tsv": "tsv", "toml": "toml", "markdown": "markdown",
            "table": "markdown", "text": "text"
          },
          "type": "enum",
          "enum_values": ["json", "csv", "yaml", "xml", "tsv", "toml", "markdown", "text"],
          "nullable": false
        },
        "source_file": {
          "question": null,
          "resolvers": ["last_mentioned_file", "last_mentioned_path", "working_memory_lookup"],
          "type": "path",
          "nullable": true
        },
        "destination_file": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "path",
          "nullable": true
        },
        "field_mapping": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "Explicit field renames or mappings if schema changes"
        },
        "filter_expression": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true
        }
      },
      "confidence_threshold": 0.65,
      "preamble": "State the input format, output format, and any field mappings before transforming. If the source is a file, read it first and confirm its structure. Show a sample of the output before writing to disk."
    },

    "api_integration": {
      "description": "Calling external APIs, building MCP servers, or handling HTTP integrations",
      "triggers": [
        "api", "endpoint", "rest", "http", "request", "curl",
        "mcp server", "mcp", "webhook", "api call", "api key",
        "post request", "get request", "api integration", "http client",
        "fetch url", "call endpoint", "rate limit", "auth token",
        "bearer token", "oauth", "api wrapper", "build mcp"
      ],
      "required_slots": ["endpoint", "method"],
      "optional_slots": ["auth_type", "payload_schema", "response_schema", "rate_limit", "base_url"],
      "slot_definitions": {
        "endpoint": {
          "question": "What is the API endpoint or URL?",
          "resolvers": ["context_inference", "last_mentioned_entity", "working_memory_lookup", "history_scan"],
          "type": "string",
          "nullable": false
        },
        "method": {
          "question": "What HTTP method — GET, POST, PUT, DELETE, or PATCH?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "get": "GET", "fetch": "GET", "read": "GET", "retrieve": "GET",
            "post": "POST", "create": "POST", "send": "POST", "submit": "POST",
            "put": "PUT", "update": "PUT", "replace": "PUT",
            "patch": "PATCH", "modify": "PATCH",
            "delete": "DELETE", "remove": "DELETE"
          },
          "type": "enum",
          "enum_values": ["GET", "POST", "PUT", "PATCH", "DELETE"],
          "nullable": false,
          "default": "GET"
        },
        "auth_type": {
          "question": null,
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "bearer": "bearer_token", "token": "bearer_token",
            "api key": "api_key", "apikey": "api_key",
            "basic": "basic_auth", "oauth": "oauth2",
            "none": "none", "no auth": "none"
          },
          "type": "enum",
          "enum_values": ["bearer_token", "api_key", "basic_auth", "oauth2", "none"],
          "nullable": true,
          "default": "none"
        },
        "payload_schema": {
          "question": null,
          "resolvers": ["context_inference", "history_scan"],
          "type": "string",
          "nullable": true
        },
        "base_url": {
          "question": null,
          "resolvers": ["context_inference", "history_scan"],
          "type": "string",
          "nullable": true
        },
        "rate_limit": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "e.g. '100/hour', '10/second'"
        }
      },
      "confidence_threshold": 0.7,
      "preamble": "State the endpoint, method, and auth mechanism before making any call. Do not hardcode credentials — reference environment variables. For MCP server builds, state the tool schema and input/output contract before writing code."
    },

    "dependency_mgmt": {
      "description": "Installing, updating, or auditing Python packages and system dependencies",
      "triggers": [
        "install package", "pip install", "install library", "install module",
        "requirements", "requirements.txt", "update package", "upgrade",
        "uninstall", "remove package", "package version", "dependency",
        "import error", "module not found", "missing package", "virtual env",
        "venv", "pip freeze", "pip list", "apt install", "apt-get"
      ],
      "required_slots": ["operation", "package_name"],
      "optional_slots": ["version_spec", "target_env", "requirements_file"],
      "slot_definitions": {
        "operation": {
          "question": "Should I install, upgrade, uninstall, or list packages?",
          "resolvers": ["keyword_map", "context_inference"],
          "keyword_map": {
            "install": "install", "add": "install", "get": "install",
            "upgrade": "upgrade", "update": "upgrade",
            "uninstall": "uninstall", "remove": "uninstall",
            "list": "list", "show": "list", "freeze": "list",
            "audit": "audit", "check": "audit"
          },
          "type": "enum",
          "enum_values": ["install", "upgrade", "uninstall", "list", "audit"],
          "nullable": false
        },
        "package_name": {
          "question": "Which package?",
          "resolvers": ["last_mentioned_entity", "working_memory_lookup", "context_inference"],
          "type": "string",
          "nullable": true,
          "note": "nullable=true allows 'list all' operations with no specific package"
        },
        "version_spec": {
          "question": null,
          "resolvers": ["context_inference"],
          "type": "string",
          "nullable": true,
          "note": "e.g. '>=1.2.0', '==2.0.1'"
        },
        "target_env": {
          "question": null,
          "resolvers": ["context_inference", "history_scan"],
          "type": "enum",
          "enum_values": ["system", "venv", "venv-a0", "user"],
          "default": "system",
          "note": "This container requires --break-system-packages for system installs"
        },
        "requirements_file": {
          "question": null,
          "resolvers": ["last_mentioned_file", "context_inference"],
          "type": "path",
          "nullable": true
        }
      },
      "confidence_threshold": 0.75,
      "preamble": "For pip installs in this container, always append --break-system-packages to the command. State the package name and version before installing. For uninstalls, confirm the package is not a transitive dependency of something critical."
    },

    "conversational": {
      "description": "General conversation, greetings, meta questions, no task implied",
      "triggers": [],
      "required_slots": [],
      "optional_slots": [],
      "slot_definitions": {},
      "confidence_threshold": 0.0,
      "preamble": null
    }
  },

  "global": {
    "ambiguous_pronouns": [
      "it", "that", "this", "them", "those", "the thing",
      "the file", "the code", "the script", "that thing"
    ],
    "underspec_phrases": [
      "make it better", "fix it", "clean it up", "do that again",
      "do it", "handle it", "take care of it", "just do it",
      "you know what to do", "figure it out", "the usual way"
    ],
    "file_extensions": {
      ".py": "python", ".js": "javascript", ".ts": "typescript",
      ".sh": "bash", ".json": "json", ".yaml": "yaml", ".yml": "yaml",
      ".md": "markdown", ".html": "html", ".css": "css",
      ".rs": "rust", ".go": "go", ".cpp": "cpp", ".c": "c",
      ".java": "java", ".rb": "ruby", ".php": "php",
      ".toml": "toml", ".ini": "ini", ".cfg": "cfg", ".env": "env",
      ".csv": "csv", ".xml": "xml", ".pdf": "pdf"
    },
    "path_patterns": [
      "\\/[a-zA-Z0-9_\\-\\.]+(?:\\/[a-zA-Z0-9_\\-\\.]+)*",
      "[a-zA-Z0-9_\\-]+\\.[a-zA-Z]{1,5}",
      "~\\/[a-zA-Z0-9_\\-\\.\\/ ]+"
    ],
    "max_clarification_questions": 2,
    "belief_state_ttl_turns": 6,
    "min_trigger_word_length": 3,
    "multi_domain_strategy": "highest_confidence",
    "fallback_domain": "conversational"
  }
}

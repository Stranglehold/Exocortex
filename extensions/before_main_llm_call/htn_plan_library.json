{
  "_meta": {
    "version": "2.0",
    "description": "Graph Workflow Library for Agent-Zero. Plans use directed graphs with branching, retry loops, and escalation nodes. Linear plans (steps array) are still supported for backward compatibility.",
    "node_types": ["start", "task", "decision", "escalate", "exit", "checkpoint"],
    "edge_conditions": ["on_success", "on_fail", "on_retry", "on_exhaust", "always"],
    "verification_types": ["output_contains", "output_not_contains", "exit_code_zero", "any_output", "file_exists", "manual"]
  },
  "plans": {
    "bugfix_workflow": {
      "name": "Bug Fix Workflow",
      "domains": ["bugfix"],
      "triggers": ["fix bug", "debug", "troubleshoot", "not working", "broken", "error in"],
      "trigger_threshold": 1,
      "stale_after_turns": 15,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin bug fix"
          },
          "reproduce": {
            "type": "task",
            "name": "Reproduce the issue",
            "action": "Run the failing code/command to confirm the bug exists and capture error output",
            "tool": "code_execution_tool",
            "tool_hint": "Run the command or script that triggers the bug",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "gather_context": {
            "type": "task",
            "name": "Gather additional context",
            "action": "Read related source files, check logs, examine the environment to understand the failure",
            "tool": "code_execution_tool",
            "tool_hint": "cat, grep, find — examine files related to the error",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "isolate": {
            "type": "task",
            "name": "Isolate the root cause",
            "action": "Examine error output and source code to identify the specific cause of the bug",
            "tool": "code_execution_tool",
            "tool_hint": "Read source files, check stack traces, add debug output if needed",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "fix": {
            "type": "task",
            "name": "Implement the fix",
            "action": "Make the minimal code change to fix the identified root cause",
            "tool": "code_execution_tool",
            "tool_hint": "Edit the file(s) with the fix",
            "verify": {"type": "any_output"},
            "max_retries": 2
          },
          "test": {
            "type": "task",
            "name": "Test the fix",
            "action": "Re-run the original failing command to confirm the bug is resolved",
            "tool": "code_execution_tool",
            "tool_hint": "Run the same command from the reproduce step",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 0
          },
          "verify_no_regression": {
            "type": "task",
            "name": "Check for regressions",
            "action": "Run related tests or commands to ensure nothing else broke",
            "tool": "code_execution_tool",
            "tool_hint": "Run test suite or check related functionality",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "escalate_stuck": {
            "type": "escalate",
            "name": "Escalate — unable to fix",
            "reason": "Fix attempts exhausted without passing tests",
            "pace_level": "contingent"
          },
          "done": {
            "type": "exit",
            "name": "Bug fix complete"
          }
        },

        "edges": [
          {"from": "start", "to": "reproduce", "condition": "always"},
          {"from": "reproduce", "to": "isolate", "condition": "on_success"},
          {"from": "reproduce", "to": "gather_context", "condition": "on_fail"},
          {"from": "gather_context", "to": "reproduce", "condition": "on_success"},
          {"from": "gather_context", "to": "escalate_stuck", "condition": "on_fail"},
          {"from": "isolate", "to": "fix", "condition": "always"},
          {"from": "fix", "to": "test", "condition": "on_success"},
          {"from": "fix", "to": "escalate_stuck", "condition": "on_exhaust"},
          {"from": "test", "to": "verify_no_regression", "condition": "on_success"},
          {"from": "test", "to": "fix", "condition": "on_fail"},
          {"from": "verify_no_regression", "to": "done", "condition": "always"}
        ]
      }
    },

    "git_feature_branch": {
      "name": "Git Feature Branch",
      "domains": ["git_ops"],
      "triggers": ["create branch", "feature branch", "new branch", "start feature", "branch off"],
      "trigger_threshold": 2,
      "stale_after_turns": 10,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin feature branch"
          },
          "check_status": {
            "type": "task",
            "name": "Check working directory status",
            "action": "Run git status and git branch to check for uncommitted changes and current branch",
            "tool": "code_execution_tool",
            "tool_hint": "git status && git branch",
            "verify": {"type": "output_contains", "value": "nothing to commit"},
            "max_retries": 0
          },
          "stash_changes": {
            "type": "task",
            "name": "Stash uncommitted changes",
            "action": "Stash or commit current changes to get a clean working state",
            "tool": "code_execution_tool",
            "tool_hint": "git stash save 'pre-branch work' or git add -A && git commit -m 'WIP: save before branch'",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 1
          },
          "create_branch": {
            "type": "task",
            "name": "Create feature branch",
            "action": "Create and checkout a new branch from main",
            "tool": "code_execution_tool",
            "tool_hint": "git checkout -b feature/<name> main",
            "verify": {"type": "output_contains", "value": "Switched to a new branch"},
            "max_retries": 1
          },
          "make_changes": {
            "type": "task",
            "name": "Implement feature changes",
            "action": "Implement the requested feature changes",
            "tool": "code_execution_tool",
            "tool_hint": "Edit the relevant files",
            "verify": {"type": "manual"},
            "max_retries": 0
          },
          "commit": {
            "type": "task",
            "name": "Commit changes",
            "action": "Stage and commit all changes with a descriptive message",
            "tool": "code_execution_tool",
            "tool_hint": "git add -A && git commit -m '<descriptive message>'",
            "verify": {"type": "output_contains", "value": "file changed"},
            "max_retries": 1
          },
          "push": {
            "type": "task",
            "name": "Push and create PR",
            "action": "Push the branch to remote and create a pull request if requested",
            "tool": "code_execution_tool",
            "tool_hint": "git push -u origin feature/<name>",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 0
          },
          "escalate_dirty": {
            "type": "escalate",
            "name": "Escalate — cannot clean working directory",
            "reason": "Unable to stash or commit existing changes to create a clean branch point",
            "pace_level": "contingent"
          },
          "done": {
            "type": "exit",
            "name": "Feature branch complete"
          }
        },

        "edges": [
          {"from": "start", "to": "check_status", "condition": "always"},
          {"from": "check_status", "to": "create_branch", "condition": "on_success"},
          {"from": "check_status", "to": "stash_changes", "condition": "on_fail"},
          {"from": "stash_changes", "to": "check_status", "condition": "on_success"},
          {"from": "stash_changes", "to": "escalate_dirty", "condition": "on_exhaust"},
          {"from": "create_branch", "to": "make_changes", "condition": "on_success"},
          {"from": "create_branch", "to": "escalate_dirty", "condition": "on_exhaust"},
          {"from": "make_changes", "to": "commit", "condition": "always"},
          {"from": "commit", "to": "push", "condition": "on_success"},
          {"from": "commit", "to": "escalate_dirty", "condition": "on_exhaust"},
          {"from": "push", "to": "done", "condition": "on_success"},
          {"from": "push", "to": "escalate_dirty", "condition": "on_fail"}
        ]
      }
    },

    "git_merge_pr": {
      "name": "Git Merge / Pull Request",
      "domains": ["git_ops"],
      "triggers": ["merge", "pull request", "merge branch", "merge into", "rebase", "merge pr"],
      "trigger_threshold": 2,
      "stale_after_turns": 10,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin merge"
          },
          "fetch": {
            "type": "task",
            "name": "Fetch latest changes",
            "action": "Fetch all remote branches to ensure up-to-date state",
            "tool": "code_execution_tool",
            "tool_hint": "git fetch --all",
            "verify": {"type": "any_output"},
            "max_retries": 1
          },
          "checkout_target": {
            "type": "task",
            "name": "Checkout target branch",
            "action": "Switch to the branch that will receive the merge",
            "tool": "code_execution_tool",
            "tool_hint": "git checkout main",
            "verify": {"type": "output_contains", "value": "Switched to"},
            "max_retries": 0
          },
          "merge": {
            "type": "task",
            "name": "Merge source branch",
            "action": "Merge the source branch into the target",
            "tool": "code_execution_tool",
            "tool_hint": "git merge <source-branch>",
            "verify": {"type": "output_not_contains", "value": "CONFLICT"},
            "max_retries": 0
          },
          "resolve_conflicts": {
            "type": "task",
            "name": "Resolve merge conflicts",
            "action": "Identify and resolve merge conflicts, then mark resolved and continue",
            "tool": "code_execution_tool",
            "tool_hint": "Check git status for conflicted files, edit them, then git add and git commit",
            "verify": {"type": "output_not_contains", "value": "conflict"},
            "max_retries": 2
          },
          "push": {
            "type": "task",
            "name": "Push merged result",
            "action": "Push the merged branch to remote",
            "tool": "code_execution_tool",
            "tool_hint": "git push origin main",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 1
          },
          "escalate_conflict": {
            "type": "escalate",
            "name": "Escalate — unresolvable merge conflicts",
            "reason": "Merge conflicts could not be resolved after multiple attempts",
            "pace_level": "contingent"
          },
          "done": {
            "type": "exit",
            "name": "Merge complete"
          }
        },

        "edges": [
          {"from": "start", "to": "fetch", "condition": "always"},
          {"from": "fetch", "to": "checkout_target", "condition": "on_success"},
          {"from": "fetch", "to": "escalate_conflict", "condition": "on_fail"},
          {"from": "checkout_target", "to": "merge", "condition": "on_success"},
          {"from": "checkout_target", "to": "escalate_conflict", "condition": "on_fail"},
          {"from": "merge", "to": "push", "condition": "on_success"},
          {"from": "merge", "to": "resolve_conflicts", "condition": "on_fail"},
          {"from": "resolve_conflicts", "to": "push", "condition": "on_success"},
          {"from": "resolve_conflicts", "to": "escalate_conflict", "condition": "on_exhaust"},
          {"from": "push", "to": "done", "condition": "on_success"},
          {"from": "push", "to": "escalate_conflict", "condition": "on_exhaust"}
        ]
      }
    },

    "docker_build_deploy": {
      "name": "Docker Build and Deploy",
      "domains": ["docker_ops"],
      "triggers": ["build image", "docker build", "deploy container", "docker deploy", "create container", "run container"],
      "trigger_threshold": 2,
      "stale_after_turns": 12,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin Docker build"
          },
          "check_dockerfile": {
            "type": "task",
            "name": "Check Dockerfile",
            "action": "Verify Dockerfile exists and review its contents",
            "tool": "code_execution_tool",
            "tool_hint": "cat Dockerfile",
            "verify": {"type": "output_contains", "value": "FROM"},
            "max_retries": 0
          },
          "build": {
            "type": "task",
            "name": "Build image",
            "action": "Build the Docker image with a descriptive tag",
            "tool": "code_execution_tool",
            "tool_hint": "docker build -t <name>:<tag> .",
            "verify": {"type": "output_contains", "value": "Successfully"},
            "max_retries": 0
          },
          "fix_dockerfile": {
            "type": "task",
            "name": "Fix Dockerfile issues",
            "action": "Examine the build error and fix the Dockerfile or build context",
            "tool": "code_execution_tool",
            "tool_hint": "Edit Dockerfile to fix the issue identified in the build output",
            "verify": {"type": "any_output"},
            "max_retries": 2
          },
          "test_image": {
            "type": "task",
            "name": "Test image",
            "action": "Run a quick smoke test to verify the image works",
            "tool": "code_execution_tool",
            "tool_hint": "docker run --rm <name>:<tag> echo 'smoke test'",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "fix_image": {
            "type": "task",
            "name": "Fix image issues",
            "action": "Examine test failure and fix the Dockerfile or application code",
            "tool": "code_execution_tool",
            "tool_hint": "Check logs with docker logs, fix the issue, rebuild",
            "verify": {"type": "any_output"},
            "max_retries": 2
          },
          "deploy": {
            "type": "task",
            "name": "Deploy container",
            "action": "Run the container with proper port mappings and volume mounts",
            "tool": "code_execution_tool",
            "tool_hint": "docker run -d --name <name> -p <host>:<container> <image>",
            "verify": {"type": "any_output"},
            "max_retries": 1
          },
          "verify_running": {
            "type": "task",
            "name": "Verify container is running",
            "action": "Check that the container started and is healthy",
            "tool": "code_execution_tool",
            "tool_hint": "docker ps && docker logs <name> | tail -5",
            "verify": {"type": "output_not_contains", "value": "Exited"},
            "max_retries": 0
          },
          "escalate_build": {
            "type": "escalate",
            "name": "Escalate — Docker build/deploy failed",
            "reason": "Unable to build, test, or deploy Docker image after multiple attempts",
            "pace_level": "contingent"
          },
          "done": {
            "type": "exit",
            "name": "Docker deploy complete"
          }
        },

        "edges": [
          {"from": "start", "to": "check_dockerfile", "condition": "always"},
          {"from": "check_dockerfile", "to": "build", "condition": "on_success"},
          {"from": "check_dockerfile", "to": "escalate_build", "condition": "on_fail"},
          {"from": "build", "to": "test_image", "condition": "on_success"},
          {"from": "build", "to": "fix_dockerfile", "condition": "on_fail"},
          {"from": "fix_dockerfile", "to": "build", "condition": "on_success"},
          {"from": "fix_dockerfile", "to": "escalate_build", "condition": "on_exhaust"},
          {"from": "test_image", "to": "deploy", "condition": "on_success"},
          {"from": "test_image", "to": "fix_image", "condition": "on_fail"},
          {"from": "fix_image", "to": "build", "condition": "on_success"},
          {"from": "fix_image", "to": "escalate_build", "condition": "on_exhaust"},
          {"from": "deploy", "to": "verify_running", "condition": "on_success"},
          {"from": "deploy", "to": "escalate_build", "condition": "on_exhaust"},
          {"from": "verify_running", "to": "done", "condition": "on_success"},
          {"from": "verify_running", "to": "escalate_build", "condition": "on_fail"}
        ]
      }
    },

    "codegen_module": {
      "name": "Code Generation — New Module",
      "domains": ["codegen"],
      "triggers": ["create module", "new component", "build feature", "create class", "new file", "scaffold"],
      "trigger_threshold": 2,
      "stale_after_turns": 12,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin code generation"
          },
          "spec_review": {
            "type": "task",
            "name": "Review specification",
            "action": "Clarify the module's purpose, inputs, outputs, and dependencies. Review existing code structure.",
            "tool": "code_execution_tool",
            "tool_hint": "Review existing code structure, identify where the new module fits",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "scaffold": {
            "type": "task",
            "name": "Scaffold file structure",
            "action": "Create the file(s) with boilerplate code, imports, and class/function stubs",
            "tool": "code_execution_tool",
            "tool_hint": "Create the file with the basic structure matching the project's patterns",
            "verify": {"type": "any_output"},
            "max_retries": 1
          },
          "implement": {
            "type": "task",
            "name": "Implement core logic",
            "action": "Fill in the function/method bodies with the actual implementation",
            "tool": "code_execution_tool",
            "tool_hint": "Write the implementation following existing code conventions",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "test": {
            "type": "task",
            "name": "Test the module",
            "action": "Run the module or its tests to verify it works correctly",
            "tool": "code_execution_tool",
            "tool_hint": "Run tests or execute the module directly to verify",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 0
          },
          "fix_implementation": {
            "type": "task",
            "name": "Fix failing tests",
            "action": "Examine test output, identify the issue, and fix the implementation",
            "tool": "code_execution_tool",
            "tool_hint": "Read the error output, edit the source to fix, then re-test",
            "verify": {"type": "any_output"},
            "max_retries": 2
          },
          "document": {
            "type": "task",
            "name": "Document usage",
            "action": "Add docstrings, comments, or usage notes as appropriate",
            "tool": "code_execution_tool",
            "tool_hint": "Add inline documentation following the project's style",
            "verify": {"type": "manual"},
            "max_retries": 0
          },
          "escalate_codegen": {
            "type": "escalate",
            "name": "Escalate — code generation failed",
            "reason": "Implementation or tests failed after multiple fix attempts",
            "pace_level": "contingent"
          },
          "done": {
            "type": "exit",
            "name": "Module generation complete"
          }
        },

        "edges": [
          {"from": "start", "to": "spec_review", "condition": "always"},
          {"from": "spec_review", "to": "scaffold", "condition": "on_success"},
          {"from": "spec_review", "to": "escalate_codegen", "condition": "on_fail"},
          {"from": "scaffold", "to": "implement", "condition": "on_success"},
          {"from": "scaffold", "to": "escalate_codegen", "condition": "on_exhaust"},
          {"from": "implement", "to": "test", "condition": "on_success"},
          {"from": "implement", "to": "escalate_codegen", "condition": "on_fail"},
          {"from": "test", "to": "document", "condition": "on_success"},
          {"from": "test", "to": "fix_implementation", "condition": "on_fail"},
          {"from": "fix_implementation", "to": "test", "condition": "on_success"},
          {"from": "fix_implementation", "to": "escalate_codegen", "condition": "on_exhaust"},
          {"from": "document", "to": "done", "condition": "always"}
        ]
      }
    },

    "refactor_safe": {
      "name": "Safe Refactor",
      "domains": ["refactor"],
      "triggers": ["refactor", "restructure", "clean up", "reorganize", "simplify", "extract function"],
      "trigger_threshold": 1,
      "stale_after_turns": 12,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin safe refactor"
          },
          "run_baseline_tests": {
            "type": "task",
            "name": "Establish test baseline",
            "action": "Run existing tests or verify current behavior to establish a baseline",
            "tool": "code_execution_tool",
            "tool_hint": "Run test suite or manually verify current behavior",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "extract_changes": {
            "type": "task",
            "name": "Plan refactoring changes",
            "action": "Identify the specific changes to make: functions to extract, renames, restructuring",
            "tool": "code_execution_tool",
            "tool_hint": "Read the code, plan the changes, identify affected files",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "modify": {
            "type": "task",
            "name": "Apply refactoring changes",
            "action": "Perform the refactoring: extract functions, rename, restructure as planned",
            "tool": "code_execution_tool",
            "tool_hint": "Make the structural changes to the code",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "run_tests_again": {
            "type": "task",
            "name": "Re-run tests after refactor",
            "action": "Run the same tests from baseline to confirm no regressions",
            "tool": "code_execution_tool",
            "tool_hint": "Run the same test command as the baseline step",
            "verify": {"type": "output_not_contains", "value": "FAILED"},
            "max_retries": 0
          },
          "revert": {
            "type": "task",
            "name": "Revert changes",
            "action": "Revert the refactoring changes since tests are failing",
            "tool": "code_execution_tool",
            "tool_hint": "git checkout -- . or git stash to restore pre-refactor state",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "commit": {
            "type": "task",
            "name": "Commit the refactor",
            "action": "Stage and commit the refactored code with a clear message",
            "tool": "code_execution_tool",
            "tool_hint": "git add <files> && git commit -m 'refactor: <description>'",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "escalate_no_baseline": {
            "type": "escalate",
            "name": "Escalate — no passing baseline",
            "reason": "Cannot refactor safely without a passing test baseline",
            "pace_level": "contingent"
          },
          "escalate_reverted": {
            "type": "escalate",
            "name": "Escalate — refactor broke tests (reverted)",
            "reason": "Refactoring caused test failures. Changes have been reverted.",
            "pace_level": "alternate"
          },
          "done": {
            "type": "exit",
            "name": "Safe refactor complete"
          }
        },

        "edges": [
          {"from": "start", "to": "run_baseline_tests", "condition": "always"},
          {"from": "run_baseline_tests", "to": "extract_changes", "condition": "on_success"},
          {"from": "run_baseline_tests", "to": "escalate_no_baseline", "condition": "on_fail"},
          {"from": "extract_changes", "to": "modify", "condition": "always"},
          {"from": "modify", "to": "run_tests_again", "condition": "on_success"},
          {"from": "modify", "to": "escalate_reverted", "condition": "on_fail"},
          {"from": "run_tests_again", "to": "commit", "condition": "on_success"},
          {"from": "run_tests_again", "to": "revert", "condition": "on_fail"},
          {"from": "revert", "to": "escalate_reverted", "condition": "always"},
          {"from": "commit", "to": "done", "condition": "always"}
        ]
      }
    },

    "file_backup_restore": {
      "name": "File Backup and Migration",
      "domains": ["file_ops"],
      "triggers": ["backup", "migrate", "move files", "copy files", "transfer", "backup files"],
      "trigger_threshold": 1,
      "stale_after_turns": 10,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin file backup"
          },
          "inventory": {
            "type": "task",
            "name": "Inventory source files",
            "action": "List and verify the files/directories to be backed up or migrated",
            "tool": "code_execution_tool",
            "tool_hint": "ls -la <source_path>",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "create_backup": {
            "type": "task",
            "name": "Create backup",
            "action": "Create a backup copy of the source files before any modification",
            "tool": "code_execution_tool",
            "tool_hint": "cp -r <source> <backup_location> or tar -czf backup.tar.gz <source>",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 1
          },
          "execute_operation": {
            "type": "task",
            "name": "Execute operation",
            "action": "Perform the actual move, copy, or migration operation",
            "tool": "code_execution_tool",
            "tool_hint": "mv/cp/rsync as appropriate for the operation",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 1
          },
          "verify_destination": {
            "type": "task",
            "name": "Verify destination",
            "action": "Confirm files arrived at destination correctly",
            "tool": "code_execution_tool",
            "tool_hint": "ls -la <destination> && diff <source_backup> <destination>",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "cleanup": {
            "type": "task",
            "name": "Cleanup",
            "action": "Remove temporary files or backup copies if no longer needed",
            "tool": "code_execution_tool",
            "tool_hint": "Remove temp files only after verification passes",
            "verify": {"type": "manual"},
            "max_retries": 0
          },
          "escalate_backup": {
            "type": "escalate",
            "name": "Escalate — backup/migration failed",
            "reason": "File operation failed. Data may need manual recovery.",
            "pace_level": "contingent"
          },
          "done": {
            "type": "exit",
            "name": "File operation complete"
          }
        },

        "edges": [
          {"from": "start", "to": "inventory", "condition": "always"},
          {"from": "inventory", "to": "create_backup", "condition": "on_success"},
          {"from": "inventory", "to": "escalate_backup", "condition": "on_fail"},
          {"from": "create_backup", "to": "execute_operation", "condition": "on_success"},
          {"from": "create_backup", "to": "escalate_backup", "condition": "on_exhaust"},
          {"from": "execute_operation", "to": "verify_destination", "condition": "on_success"},
          {"from": "execute_operation", "to": "escalate_backup", "condition": "on_exhaust"},
          {"from": "verify_destination", "to": "cleanup", "condition": "on_success"},
          {"from": "verify_destination", "to": "escalate_backup", "condition": "on_fail"},
          {"from": "cleanup", "to": "done", "condition": "always"}
        ]
      }
    },

    "api_integration": {
      "name": "API Integration",
      "domains": ["api_integration"],
      "triggers": ["connect api", "integrate", "endpoint", "api call", "rest api", "webhook"],
      "trigger_threshold": 2,
      "stale_after_turns": 12,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin API integration"
          },
          "research_api": {
            "type": "task",
            "name": "Research the API",
            "action": "Check API documentation, find base URL, auth method, and available endpoints",
            "tool": "code_execution_tool",
            "tool_hint": "curl -s <api_docs_url> or check README/docs",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "setup_auth": {
            "type": "task",
            "name": "Set up authentication",
            "action": "Configure API keys, tokens, or credentials as required",
            "tool": "code_execution_tool",
            "tool_hint": "Export API key or create auth config",
            "verify": {"type": "any_output"},
            "max_retries": 1
          },
          "implement": {
            "type": "task",
            "name": "Implement the integration",
            "action": "Write the code to call the API endpoint with proper auth and parameters",
            "tool": "code_execution_tool",
            "tool_hint": "Write a script using requests/curl to call the endpoint",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "test_call": {
            "type": "task",
            "name": "Test the API call",
            "action": "Execute the API call and verify the response",
            "tool": "code_execution_tool",
            "tool_hint": "Run the integration script and check response status/body",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 0
          },
          "debug_response": {
            "type": "task",
            "name": "Debug API response",
            "action": "Examine the error response, check auth, headers, and parameters. Fix the integration.",
            "tool": "code_execution_tool",
            "tool_hint": "curl -v for verbose output, check response body for error details",
            "verify": {"type": "any_output"},
            "max_retries": 2
          },
          "add_error_handling": {
            "type": "task",
            "name": "Add error handling",
            "action": "Add retry logic, timeout handling, and error response parsing",
            "tool": "code_execution_tool",
            "tool_hint": "Add try/except, status code checks, timeout parameters",
            "verify": {"type": "manual"},
            "max_retries": 0
          },
          "escalate_api": {
            "type": "escalate",
            "name": "Escalate — API integration failed",
            "reason": "API calls failing after multiple debug attempts. May need different credentials or approach.",
            "pace_level": "contingent"
          },
          "done": {
            "type": "exit",
            "name": "API integration complete"
          }
        },

        "edges": [
          {"from": "start", "to": "research_api", "condition": "always"},
          {"from": "research_api", "to": "setup_auth", "condition": "on_success"},
          {"from": "research_api", "to": "escalate_api", "condition": "on_fail"},
          {"from": "setup_auth", "to": "implement", "condition": "on_success"},
          {"from": "setup_auth", "to": "escalate_api", "condition": "on_exhaust"},
          {"from": "implement", "to": "test_call", "condition": "on_success"},
          {"from": "implement", "to": "escalate_api", "condition": "on_fail"},
          {"from": "test_call", "to": "add_error_handling", "condition": "on_success"},
          {"from": "test_call", "to": "debug_response", "condition": "on_fail"},
          {"from": "debug_response", "to": "test_call", "condition": "on_success"},
          {"from": "debug_response", "to": "escalate_api", "condition": "on_exhaust"},
          {"from": "add_error_handling", "to": "done", "condition": "always"}
        ]
      }
    },

    "dependency_update": {
      "name": "Dependency Update",
      "domains": ["dependency_mgmt"],
      "triggers": ["update deps", "upgrade packages", "update dependencies", "pip upgrade", "npm update", "outdated"],
      "trigger_threshold": 1,
      "stale_after_turns": 10,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin dependency update"
          },
          "audit": {
            "type": "task",
            "name": "Audit current state",
            "action": "List current dependencies and check for outdated packages",
            "tool": "code_execution_tool",
            "tool_hint": "pip list --outdated or npm outdated",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "backup_lockfile": {
            "type": "task",
            "name": "Backup lockfile",
            "action": "Create a backup of the current lockfile before making changes",
            "tool": "code_execution_tool",
            "tool_hint": "cp requirements.txt requirements.txt.bak or cp package-lock.json package-lock.json.bak",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 0
          },
          "perform_update": {
            "type": "task",
            "name": "Perform update",
            "action": "Update the target packages to their latest compatible versions",
            "tool": "code_execution_tool",
            "tool_hint": "pip install --upgrade <package> or npm update <package>",
            "verify": {"type": "output_not_contains", "value": "error"},
            "max_retries": 1
          },
          "run_tests": {
            "type": "task",
            "name": "Run tests",
            "action": "Verify the application still works with updated dependencies",
            "tool": "code_execution_tool",
            "tool_hint": "Run the project's test suite",
            "verify": {"type": "output_not_contains", "value": "FAILED"},
            "max_retries": 0
          },
          "rollback": {
            "type": "task",
            "name": "Rollback update",
            "action": "Restore the original lockfile and reinstall previous versions",
            "tool": "code_execution_tool",
            "tool_hint": "cp requirements.txt.bak requirements.txt && pip install -r requirements.txt",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "commit": {
            "type": "task",
            "name": "Commit updated lockfile",
            "action": "Commit the updated dependency files",
            "tool": "code_execution_tool",
            "tool_hint": "git add requirements.txt package-lock.json && git commit -m 'deps: update packages'",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "escalate_deps": {
            "type": "escalate",
            "name": "Escalate — dependency update failed",
            "reason": "Tests fail with updated dependencies. Previous versions restored.",
            "pace_level": "alternate"
          },
          "done": {
            "type": "exit",
            "name": "Dependency update complete"
          }
        },

        "edges": [
          {"from": "start", "to": "audit", "condition": "always"},
          {"from": "audit", "to": "backup_lockfile", "condition": "on_success"},
          {"from": "audit", "to": "escalate_deps", "condition": "on_fail"},
          {"from": "backup_lockfile", "to": "perform_update", "condition": "on_success"},
          {"from": "backup_lockfile", "to": "escalate_deps", "condition": "on_fail"},
          {"from": "perform_update", "to": "run_tests", "condition": "on_success"},
          {"from": "perform_update", "to": "rollback", "condition": "on_exhaust"},
          {"from": "run_tests", "to": "commit", "condition": "on_success"},
          {"from": "run_tests", "to": "rollback", "condition": "on_fail"},
          {"from": "rollback", "to": "escalate_deps", "condition": "always"},
          {"from": "commit", "to": "done", "condition": "always"}
        ]
      }
    },

    "log_investigation": {
      "name": "Log Investigation",
      "domains": ["log_analysis"],
      "triggers": ["check logs", "investigate", "diagnose", "log analysis", "what went wrong", "find error in logs"],
      "trigger_threshold": 1,
      "stale_after_turns": 10,

      "graph": {
        "start": "start",

        "nodes": {
          "start": {
            "type": "start",
            "name": "Begin log investigation"
          },
          "locate_sources": {
            "type": "task",
            "name": "Locate log sources",
            "action": "Find and identify the relevant log files or output streams",
            "tool": "code_execution_tool",
            "tool_hint": "ls -la /var/log/ or find . -name '*.log' -mtime -1",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "check_alternatives": {
            "type": "task",
            "name": "Check alternative log sources",
            "action": "Look for logs in non-standard locations: journalctl, docker logs, application-specific paths",
            "tool": "code_execution_tool",
            "tool_hint": "journalctl --since '1 hour ago' or docker logs <container> or check app config for log path",
            "verify": {"type": "any_output"},
            "max_retries": 1
          },
          "filter_entries": {
            "type": "task",
            "name": "Filter relevant entries",
            "action": "Search logs for error patterns, timestamps, or keywords related to the issue",
            "tool": "code_execution_tool",
            "tool_hint": "grep -i 'error\\|warn\\|fail' <logfile> | tail -50",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "broaden_search": {
            "type": "task",
            "name": "Broaden search terms",
            "action": "Widen the search criteria: remove filters, look at larger time window, check related logs",
            "tool": "code_execution_tool",
            "tool_hint": "Use broader grep patterns, check earlier timestamps, look at adjacent log files",
            "verify": {"type": "any_output"},
            "max_retries": 1
          },
          "identify_pattern": {
            "type": "task",
            "name": "Identify error pattern",
            "action": "Analyze filtered log entries to find the recurring pattern or root event",
            "tool": "code_execution_tool",
            "tool_hint": "Sort and count error types, check timestamps for correlation",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "trace_root_cause": {
            "type": "task",
            "name": "Trace root cause",
            "action": "Follow the error chain back to its origin — first occurrence, triggering event, upstream dependency",
            "tool": "code_execution_tool",
            "tool_hint": "Check the earliest error timestamp, trace call stack, check related services",
            "verify": {"type": "any_output"},
            "max_retries": 0
          },
          "report": {
            "type": "task",
            "name": "Report findings",
            "action": "Summarize the diagnosis: what happened, why, and recommended fix",
            "tool": "response",
            "tool_hint": "Present findings clearly: root cause, evidence, recommended action",
            "verify": {"type": "manual"},
            "max_retries": 0
          },
          "escalate_logs": {
            "type": "escalate",
            "name": "Escalate — cannot identify root cause",
            "reason": "Unable to locate or parse relevant logs to determine root cause",
            "pace_level": "alternate"
          },
          "done": {
            "type": "exit",
            "name": "Investigation complete"
          }
        },

        "edges": [
          {"from": "start", "to": "locate_sources", "condition": "always"},
          {"from": "locate_sources", "to": "filter_entries", "condition": "on_success"},
          {"from": "locate_sources", "to": "check_alternatives", "condition": "on_fail"},
          {"from": "check_alternatives", "to": "filter_entries", "condition": "on_success"},
          {"from": "check_alternatives", "to": "escalate_logs", "condition": "on_exhaust"},
          {"from": "filter_entries", "to": "identify_pattern", "condition": "on_success"},
          {"from": "filter_entries", "to": "broaden_search", "condition": "on_fail"},
          {"from": "broaden_search", "to": "filter_entries", "condition": "on_success"},
          {"from": "broaden_search", "to": "escalate_logs", "condition": "on_exhaust"},
          {"from": "identify_pattern", "to": "trace_root_cause", "condition": "on_success"},
          {"from": "identify_pattern", "to": "escalate_logs", "condition": "on_fail"},
          {"from": "trace_root_cause", "to": "report", "condition": "on_success"},
          {"from": "trace_root_cause", "to": "escalate_logs", "condition": "on_fail"},
          {"from": "report", "to": "done", "condition": "always"}
        ]
      }
    }
  }
}
